use std::str::FromStr;
// use crate::ast::FunctionDef;
// use crate::ast::FuncDef;
// use crate::ast::Expr;
// use crate::ast::Statement;

use super::tokens::*;
use crate::ast_nodes::program::{Program, Statement};
use crate::ast_nodes::expression::Expression;
use crate::ast_nodes::let_in::Assignment;
use crate::ast_nodes::function_def::{FunctionDefNode,FunctionParams};
use crate::ast_nodes::block::ExpressionList;
use crate::tokens::Token;
use lalrpop_util::ParseError;

pub type ParseError = lalrpop_util::ParseError<usize, Token, &'static str>;

pub fn format_error(error: ParseError) -> String {
    match error {
        ParseError::InvalidToken { location } => 
            format!("Token inv치lido en posici칩n {}", location),
        ParseError::UnrecognizedToken { token: Some((l, token, r)), expected } => 
            format!("Token inesperado '{}' en posici칩n {}. Se esperaba: {}", token, l, expected.join(", ")),
        ParseError::ExtraToken { token: (l, token) } => 
            format!("Token extra '{}' en posici칩n {}", token, l),
        ParseError::User { error } => 
            format!("Error de sintaxis: {}", error),
        _ => format!("Error desconocido: {:?}", error)
    }
}

grammar;

pub Program: Program = {
    <v:(<Statement> Semicolon)*> <last:Statement?> => {
        let mut vec = v;
        if let Some(e) = last {
            vec.push(e);
        }
        Program{statements:vec,}
    }
}

Statement: Statement = {
    FunctionFullDef => Statement::new_function_def(<>),
    FunctionArrowDef => Statement::new_function_def(<>),
    Expr => Statement::new_expression(<>)
}

FunctionArrowDef: FunctionDefNode = {
    Function <name:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> Arrow <body:Expr> => {
        FunctionDefNode::new_expr(name,params,s,body)
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> Arrow <body:Expr> => {
        FunctionDefNode::new_expr(name,vec![],s,body)
    }
};

FunctionFullDef: FunctionDefNode = {
    Function <name:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> <body:CodeBlock> => {
        FunctionDefNode::new_expr(name,params,s,body)
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> <body:CodeBlock> => {
        FunctionDefNode::new_expr(name,vec![],s,body)
    }
};

Expr: Expression = { 
    DestructiveAssignExpr,
    LogicalOrExpr
};

DestructiveAssignExpr: Expression = {
    <id:Identifier> DestructiveAssignOp <e:Expr> => {
        Expression::new_destructive_assign(id, e)
    }
};

ExprsList: ExpressionList = {
    <v:(<Expr> Semicolon)*> <last:Expr?> => {
        let mut vec = v;
        if let Some(e) = last {
            vec.push(e);
        }
        ExpressionList::new(vec)
    }
};

LogicalOrExpr: Expression = {
    LogicalOrExpr LogicalOrOp LogicalAndExpr => Expression::new_binary_op(<>),
    LogicalAndExpr
};

LogicalAndExpr: Expression = {
    LogicalAndExpr LogicalAndOp EqualityExpr => Expression::new_binary_op(<>),
    EqualityExpr
};

EqualityExpr: Expression = {
    EqualityExpr EqualityOp ComparisonExpr => Expression::new_binary_op(<>),
    ComparisonExpr,
};

ComparisonExpr: Expression = {
    ComparisonExpr ComparisonOp TermExpr => Expression::new_binary_op(<>),
    TermExpr,
};

TermExpr: Expression = {
    TermExpr TermOp FactorExpr => Expression::new_binary_op(<>),
    FactorExpr,
};

FactorExpr: Expression = {
    FactorExpr FactorOp ExponentExpr => Expression::new_binary_op(<>),
    ExponentExpr,
};

ExponentExpr: Expression = {
    UnaryExpr PowOp ExponentExpr => Expression::new_binary_op(<>),
    UnaryExpr,
};

UnaryExpr: Expression = {
    UnaryOp UnaryExpr => Expression::new_unary_op(<>),
    PrimaryExpr,
};

IdentifierList: Vec<FunctionParams> = {
    <first:Identifier> Colon <s:Signature> <rest:(Comma Identifier Colon Signature)*> => {
        let mut vec = vec![FunctionParams::new(first,s)];
        for (_, id,_,signature) in rest {
            vec.push(FunctionParams::new(id,signature));
        }
        vec
    }
};

Assignment: Assignment = {
    <id:Identifier> Assign <e:Expr> => Assignment::new(id,e),
}

AssignmentList: Vec<Assignment> = {
    <l:AssignmentList> "," <r:Assignment> => {
        let mut l = l;
        l.push(r);
        l
    },
    <r:Assignment> => {
        let mut v = Vec::new();
        v.push(r);
        v
    },
}

ArgList: Vec<Expression> = {
    // Handle non-empty arguments
    <first:Expr> <rest:(<Comma> <Expr>)*> => {
        let mut args = vec![first];
        for (_, expr) in rest {
            args.push(expr);
        }
        args
    },
    // Handle empty arguments (no parameters)
    => Vec::new()
};

CodeBlock: Expression = {
    LBrace <body:ExprsList> RBrace => Expression::new_code_block(body),
}

LetIn: Expression = {
    Let <a:AssignmentList> In <body:PrimaryExpr> => Expression::new_let_in(a,body),
};

WhileLoop: Expression = {
    While LParen <condition:Expr> RParen <body:PrimaryExpr> => Expression::new_while_loop(condition,body),
};

//Maybe catch these errors in a different place (Like Semantic Analysis)
ForLoop: Expression = {
    For LParen <id:Identifier> In <call:PrimaryExpr> RParen <body:PrimaryExpr> => {
        if let Expression::FunctionCall(func_call) = call {
            if func_call.function_name == "range" && func_call.arguments.len() == 2 {
                let mut args = func_call.arguments;
                let start = args.remove(0);
                let end = args.remove(0);
                
                Expression::new_for_loop(id, start, end, body)
            } else {
                panic!("For loop must use `range` with exactly two arguments");
            }
        } else {
            panic!("For loop iterable must be a `range` function call");
        }
    }
};

IfElse: Expression = {
    If LParen <condition:Expr> RParen <if_body:PrimaryExpr> Else <else_body:PrimaryExpr> => {
        Expression::new_if_else(condition,if_body,else_body)
    },
}

PrimaryExpr: Expression = {
    WhileLoop,
    ForLoop,
    <name:Identifier> LParen <args:ArgList> RParen => Expression::new_function_call(name, args),
    Num => Expression::new_number(<>),
    Str => Expression::new_string(<>),
    Identifier => Expression::new_identifier(<>),
    LParen <Expr> RParen => <>,
    LetIn,
    True => Expression::new_boolean(true),
    False => Expression::new_boolean(false),
    CodeBlock,
    IfElse,
};

Identifier: Token = {
    r"[A-Za-z][A-Za-z_0-9]*" => Token::Identifier(String::from_str(<>).unwrap()),
};

Num: Token = {
    r"[0-9]+(\.[0-9]+)?" => Token::Number(String::from_str(<>).unwrap()),
};

Str: Token = {
    r#""([^"\\]|\\.)*""# => Token::StringLiteral(String::from_str(&<>[1..<>.len()-1]).unwrap()),
};

// PrintExpr: Box<Expr> = {
//     Print LParen <Expr> RParen => Box::new(Expr::Print(<>)),
// };

UnaryOp: Token = {
    "!" => Token::Operator(OperatorToken::NOT),
    "-" => Token::Operator(OperatorToken::NEG),
};

PowOp: Token = {
    "^" => Token::Operator(OperatorToken::POW),
};

FactorOp: Token = {
    "*" => Token::Operator(OperatorToken::MUL),
    "/" => Token::Operator(OperatorToken::DIV),
    "%" => Token::Operator(OperatorToken::MOD),
};

TermOp: Token = {
    "+" => Token::Operator(OperatorToken::PLUS),
    "-" => Token::Operator(OperatorToken::MINUS),
    "@" => Token::Operator(OperatorToken::CONCAT),
};

ComparisonOp: Token = {
    ">" => Token::Operator(OperatorToken::GT),
    ">=" => Token::Operator(OperatorToken::GTE),
    "<" => Token::Operator(OperatorToken::LT),
    "<=" => Token::Operator(OperatorToken::LTE),
};

Function: Token = {
    "function" => Token::Keyword(KeywordToken::FUNCTION),
};


Arrow: Token = {
    "=>" => Token::Delimiter(DelimiterToken::ARROW),
};

EqualityOp: Token = {
    "==" => Token::Operator(OperatorToken::EQ),
    "!=" => Token::Operator(OperatorToken::NEQ),
};

Comma: Token = {
    "," => Token::Delimiter(DelimiterToken::COMMA),
};

Colon: Token = {
    ":" => Token::Delimiter(DelimiterToken::COLON),
};

Assign: Token = {
    "=" => Token::Operator(OperatorToken::ASSIGN),
};

DestructiveAssignOp: Token = {
    ":=" => Token::Operator(OperatorToken::DASSIGN),
};

LogicalAndOp: Token = {
    "&" => Token::Operator(OperatorToken::AND),
};

LogicalOrOp: Token = {
    "|" => Token::Operator(OperatorToken::OR),
};

Semicolon: Token = {
    ";" => Token::Delimiter(DelimiterToken::SEMICOLON),
};

LParen: Token = {
    "(" => Token::Delimiter(DelimiterToken::LPAREN),
};

RParen: Token = {
    ")" => Token::Delimiter(DelimiterToken::RPAREN),
};

RBrace: Token = {
    "}" => Token::Delimiter(DelimiterToken::RBRACE),
};

LBrace: Token = {
    "{" => Token::Delimiter(DelimiterToken::LBRACE),
};

Let: Token = {
    "let" =>Token::Keyword( KeywordToken::LET),
};

Else: Token = {
    "else" => Token::Keyword(KeywordToken::ELSE),
};

Elif: Token = {
    "elif" => Token::Keyword(KeywordToken::ELIF),
};

In: Token = {
    "in" => Token::Keyword(KeywordToken::IN),
};

If: Token = {
    "if" => Token::Keyword(KeywordToken::IF),
};

While: Token = {
    "while" => Token::Keyword(KeywordToken::WHILE),
};

For: Token = {
    "for" => Token::Keyword(KeywordToken::FOR),
};

// Print: KeywordToken = {
//     "print" => KeywordToken::PRINT,
// };

True: Token = {
    "true" => Token::Keyword(KeywordToken::TRUE),
};

False: Token = {
    "false" => Token::Keyword(KeywordToken::FALSE),
};

Signature: Token = {
    r"[A-Za-z][A-Za-z_0-9]*" => Token::Identifier(String::from_str(<>).unwrap()),
};

