use std::str::FromStr;
// use crate::ast::FunctionDef;
// use crate::ast::FuncDef;
// use crate::ast::Expr;
// use crate::ast::Statement;

use super::tokens::*;
use crate::ast_nodes::program::{Program, Statement};
use crate::ast_nodes::expression::Expression;
use crate::ast_nodes::let_in::Assignment;
use crate::ast_nodes::function_def::{FunctionDefNode,FunctionParams};
use crate::ast_nodes::block::ExpressionList;
use crate::ast_nodes::type_def::{TypeDefNode, TypeInherits, TypeMember};
use crate::ast_nodes::function_call::FunctionCallNode;

grammar;

pub Program: Program = {
    <v:(<Statement> Semicolon)*> <last:Statement?> Semicolon  => {
        let mut vec = v;
        if let Some(e) = last {
            vec.push(e);
        }
        Program{statements:vec,}
    }
}

Statement: Statement = {
    FunctionFullDef => Statement::new_function_def(<>),
    FunctionArrowDef => Statement::new_function_def(<>),
    TypeDef => Statement::new_type_def(<>),
    Expr => Statement::new_expression(<>)
}

FunctionArrowDef: FunctionDefNode = {
    Function <name:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> Arrow <body:Expr> => {
        FunctionDefNode::new_expr(name,params,s,body)
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> Arrow <body:Expr> => {
        FunctionDefNode::new_expr(name,vec![],s,body)
    }
};

FunctionFullDef: FunctionDefNode = {
    Function <name:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> <body:CodeBlock> => {
        FunctionDefNode::new_expr(name,params,s,body)
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> <body:CodeBlock> => {
        FunctionDefNode::new_expr(name,vec![],s,body)
    }
};

FunctionCall: Expression = {
    <name:Identifier> <args:ArgList> => Expression::new_function_call(name, args)
};

TypeDef: TypeDefNode = {
    Type <name:Identifier> <p:Params?> <i:Inheritance?> LBrace <b:TypeBodyDef> RBrace => {
        let p = if let Some(params) = p {
            params
        } else {
            Vec::new()
        };
        if let Some(inherits) = i {
            TypeDefNode::new(name, p, Some(inherits.identifier), inherits.params, b)
        } else {
            TypeDefNode::new(name, p, None, Vec::new(), b)
        }
    }
};

TypeBodyDef: Vec<TypeMember> = {
    <h:(<MemberDef> Semicolon)*> <t:MemberDef?> => {
        let mut vec = h;
        if let Some(e) = t {
            vec.push(e);
        }
        vec
    }
};

MemberDef: TypeMember = {
    TypeMemberAssignment,
    TypeMemberFunctionDef
};

TypeMemberAssignment: TypeMember = {
    <id:Identifier> Assign <e:Expr> => TypeMember::new_property(Assignment::new(id,e)),
};

TypeMemberFunctionDef: TypeMember = {
    <i:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> Arrow <body:Expr> => {
        TypeMember::new_method(FunctionDefNode::new_expr(i,params,s,body))
    },
    <i:Identifier> LParen RParen Colon <s:Signature> Arrow <body:Expr> => {
        TypeMember::new_method(FunctionDefNode::new_expr(i,Vec::new(),s,body))
    },
    <i:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> <body:CodeBlock> => {
        TypeMember::new_method(FunctionDefNode::new_expr(i,params,s,body))
    },
    <i:Identifier> LParen RParen Colon <s:Signature> <body:CodeBlock> => {
        TypeMember::new_method(FunctionDefNode::new_expr(i,Vec::new(),s,body))
    }
};


Inheritance: TypeInherits = {
    Inherits <parent:Identifier> <p:ArgList> => TypeInherits::new(parent, p),
    Inherits <parent:Identifier> => TypeInherits::new(parent, Vec::new())
}

TypeFunctionAccess: Expression = {
    <object:PrimaryExpr> DotOp <name:Identifier> <args:ArgList> => Expression::new_type_function_access(object, FunctionCallNode::new(name, args)),
}

TypePropAccess: Expression = {
    <object:PrimaryExpr> DotOp <name:Identifier> => Expression::new_type_prop_access(object, name),
};

Expr: Expression = { 
    DestructiveAssignExpr ,
    LogicalOrExpr 
};

DestructiveAssignExpr: Expression = {
    <id:PrimaryExpr> DestructiveAssignOp <e:Expr> => {
        Expression::new_destructive_assign(id, e)
    }
};

ExprsList: ExpressionList = {
    <v:(<Expr> Semicolon)*> <last:Expr?> => {
        let mut vec = v;
        if let Some(e) = last {
            vec.push(e);
        }
        ExpressionList::new(vec)
    }
};

LogicalOrExpr: Expression = {
    LogicalOrExpr LogicalOrOp LogicalAndExpr => Expression::new_binary_op(<>),
    LogicalAndExpr
};

LogicalAndExpr: Expression = {
    LogicalAndExpr LogicalAndOp EqualityExpr => Expression::new_binary_op(<>),
    EqualityExpr
};

EqualityExpr: Expression = {
    EqualityExpr EqualityOp ComparisonExpr => Expression::new_binary_op(<>),
    ComparisonExpr,
};

ComparisonExpr: Expression = {
    ComparisonExpr ComparisonOp TermExpr => Expression::new_binary_op(<>),
    TermExpr,
};

TermExpr: Expression = {
    TermExpr TermOp FactorExpr => Expression::new_binary_op(<>),
    FactorExpr,
};

FactorExpr: Expression = {
    FactorExpr FactorOp ExponentExpr => Expression::new_binary_op(<>),
    ExponentExpr,
};

ExponentExpr: Expression = {
    UnaryExpr PowOp ExponentExpr => Expression::new_binary_op(<>),
    UnaryExpr,
};

UnaryExpr: Expression = {
    UnaryOp UnaryExpr => Expression::new_unary_op(<>),
    CompositeExpr,
};

IdentifierList: Vec<FunctionParams> = {
    <first:Identifier> Colon <s:Signature> <rest:(Comma Identifier Colon Signature)*> => {
        let mut vec = vec![FunctionParams::new(first,s)];
        for (_, id,_,signature) in rest {
            vec.push(FunctionParams::new(id,signature));
        }
        vec
    }
};

Params: Vec<FunctionParams> = {
    LParen <params:IdentifierList> RParen => params,
    LParen RParen => Vec::new()
};

Assignment: Assignment = {
    <id:Identifier> Assign <e:Expr> => Assignment::new(id,e),
}

AssignmentList: Vec<Assignment> = {
    <l:AssignmentList> "," <r:Assignment> => {
        let mut l = l;
        l.push(r);
        l
    },
    <r:Assignment> => {
        let mut v = Vec::new();
        v.push(r);
        v
    },
}

PropsAssigment: Vec<Assignment> = {
    <h:PropsAssigment> ";" <t:Assignment> => {
        let mut h = h;
        h.push(t);
        h
    },
    <t:Assignment> => {
        let mut v = Vec::new();
        v.push(t);
        v
    },
}

ArgList: Vec<Expression> = {
    // Handle non-empty arguments
    LParen <first:Expr> <rest:(<Comma> <Expr>)*> RParen => {
        let mut args = vec![first];
        for (_, expr) in rest {
            args.push(expr);
        }
        args
    },
    // Handle empty arguments (no parameters)
    LParen RParen => Vec::new()
};

CodeBlock: Expression = {
    LBrace <body:ExprsList> RBrace => Expression::new_code_block(body),
}

LetIn: Expression = {
    Let <a:AssignmentList> In <body:CompositeExpr> => Expression::new_let_in(a,body),
};

WhileLoop: Expression = {
    While LParen <condition:Expr> RParen <body:CompositeExpr> => Expression::new_while_loop(condition,body),
};

//Maybe catch these errors in a different place (Like Semantic Analysis)
ForLoop: Expression = {
    For LParen <id:Identifier> In <call:CompositeExpr> RParen <body:CompositeExpr> => Expression::new_for_loop(id, call, body)
};

IfElse: Expression = {
    If LParen <condition:Expr> RParen <if_body:CodeBlock> => Expression::new_if_else(condition,if_body,Vec::new()),
    If LParen <condition:Expr> RParen <if_body:CodeBlock> <else_or_elif:ElseOrElif> => Expression::new_if_else(condition, if_body, else_or_elif)
}

ElseOrElif: Vec<(Option<Expression>,Expression)> = {
    Else <else_expr:CodeBlock> => vec![(None,else_expr)],
    Elif LParen <cond:Expr> RParen <body:CodeBlock> <rest:ElseOrElif> => {
        let mut exprs = vec![(Some(cond),body)];
        exprs.extend(rest);
        return exprs;
    }
}

CompositeExpr: Expression = {
    LetIn,
    IfElse,
    WhileLoop,
    ForLoop,
    PrimaryExpr,
}

PrimaryExpr: Expression = {
    FunctionCall,
    New <name:Identifier> <args:ArgList> => Expression::new_type_instance(name, args),
    TypeFunctionAccess,
    TypePropAccess,
    Num => Expression::new_number(<>),
    Str => Expression::new_string(<>),
    Identifier => Expression::new_identifier(<>),
    LParen <Expr> RParen => <>,
    True => Expression::new_boolean(true),
    False => Expression::new_boolean(false),
    CodeBlock,
    PrintExpr,
};

Identifier: String = {
    r"[A-Za-z][A-Za-z_0-9]*" => String::from_str(<>).unwrap(),
};

Num: String = {
    r"[0-9]+(\.[0-9]+)?" => String::from_str(<>).unwrap(),
};

Str: String = {
    r#""([^"\\]|\\.)*""# => String::from_str(&<>[1..<>.len()-1]).unwrap(),
};

PrintExpr: Expression = {
    Print LParen <Expr> RParen => Expression::new_print(<>),
};

UnaryOp: OperatorToken = {
    "!" => OperatorToken::NOT,
    "-" => OperatorToken::NEG,
};

PowOp: OperatorToken = {
    "^" => OperatorToken::POW,
};

FactorOp: OperatorToken = {
    "*" => OperatorToken::MUL,
    "/" => OperatorToken::DIV,
    "%" => OperatorToken::MOD,
};

TermOp: OperatorToken = {
    "+" => OperatorToken::PLUS,
    "-" => OperatorToken::MINUS,
    "@" => OperatorToken::CONCAT,
};

ComparisonOp: OperatorToken = {
    ">" => OperatorToken::GT,
    ">=" => OperatorToken::GTE,
    "<" => OperatorToken::LT,
    "<=" => OperatorToken::LTE,
};

Function: KeywordToken = {
    "function" => KeywordToken::FUNCTION,
};

Arrow: DelimiterToken = {
    "=>" => DelimiterToken::ARROW,
};

EqualityOp: OperatorToken = {
    "==" => OperatorToken::EQ,
    "!=" => OperatorToken::NEQ,
};

Comma: DelimiterToken = {
    "," => DelimiterToken::COMMA,
};

Colon:  DelimiterToken = {
    ":" => DelimiterToken::COLON
}

Assign: OperatorToken = {
    "=" => OperatorToken::ASSIGN,
};

DestructiveAssignOp: OperatorToken = {
    ":=" => OperatorToken::DASSIGN
};

LogicalAndOp: OperatorToken = {
    "&" => OperatorToken::AND,
};

LogicalOrOp: OperatorToken = {
    "|" => OperatorToken::OR,
};

DotOp: OperatorToken = {
    "." => OperatorToken::DOT
};

Semicolon: DelimiterToken = {
    ";" => DelimiterToken::SEMICOLON,
};

RParen: DelimiterToken = {
    ")" => DelimiterToken::RPAREN,
};

LParen: DelimiterToken = {
    "(" => DelimiterToken::LPAREN,
};

RBrace: DelimiterToken = {
    "}" => DelimiterToken::RBRACE,
};

LBrace: DelimiterToken = {
    "{" => DelimiterToken::LBRACE,
};

Let: KeywordToken = {
    "let" => KeywordToken::LET,
};

Else: KeywordToken = {
    "else" => KeywordToken::ELSE,
};

Elif: KeywordToken = {
    "elif" => KeywordToken::ELIF,
};

In: KeywordToken = {
    "in" => KeywordToken::IN,
};

If: KeywordToken = {
    "if" => KeywordToken::IF,
};

While: KeywordToken = {
    "while" => KeywordToken::WHILE,
};

For: KeywordToken = {
    "for" => KeywordToken::FOR,
};

Type: KeywordToken = {
    "type" => KeywordToken::TYPE,
}

Inherits: KeywordToken = {
    "inherits" => KeywordToken::INHERITS,
};

New: KeywordToken = {
    "new" => KeywordToken::NEW,
};

Print: KeywordToken = {
    "print" => KeywordToken::PRINT,
};

True: KeywordToken = {
    "true" => KeywordToken::TRUE,
};

False: KeywordToken = {
    "false" => KeywordToken::FALSE,
};

Signature: String = {
    r"[A-Za-z][A-Za-z_0-9]*" => String::from_str(<>).unwrap(),
}

