use std::str::FromStr;
// use crate::ast::FunctionDef;
// use crate::ast::FuncDef;
// use crate::ast::Expr;
// use crate::ast::Statement;

use super::tokens::*;
use crate::ast_nodes::program::{Program, Statement};
use crate::ast_nodes::expression::Expression;
use crate::ast_nodes::let_in::Assignment;
use crate::ast_nodes::function_def::{FunctionDefNode,FunctionParams};
use crate::ast_nodes::block::ExpressionList;
use crate::tokens::Token;
use lalrpop_util::ParseError;
use crate::parser::{extract_identifier, extract_number, extract_string, extract_signature, extract_operator, format_error};

grammar;

pub Program: Result<Program, String> = {
    <v:(<Statement> Semicolon)*> <last:Statement?> => {
        let mut vec = v.into_iter().collect::<Result<Vec<_>, _>>()?;
        if let Some(e) = last {
            vec.push(e?);
        }
        Ok(Program{statements:vec})
    }
}

Statement: Result<Statement, String> = {
    FunctionFullDef => Ok(Statement::new_function_def(<>?)),
    FunctionArrowDef => Ok(Statement::new_function_def(<>?)),
    Expr => Ok(Statement::new_expression(<>?))
}

FunctionArrowDef: Result<FunctionDefNode, String> = {
    Function <name:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> Arrow <body:Expr> => {
        let name_str = extract_identifier(name)?;
        let signature_str = extract_signature(s)?;
        FunctionDefNode::new_expr(name_str, params?, signature_str, body?)
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> Arrow <body:Expr> => {
        let name_str = extract_identifier(name)?;
        let signature_str = extract_signature(s)?;
        FunctionDefNode::new_expr(name_str, vec![], signature_str, body?)
    }
};

FunctionFullDef: Result<FunctionDefNode, String> = {
    Function <name:Identifier> LParen <params:IdentifierList> RParen Colon <s:Signature> <body:CodeBlock> => {
        let name_str = extract_identifier(name)?;
        let signature_str = extract_signature(s)?;
        FunctionDefNode::new_expr(name_str, params?, signature_str, body?)
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> <body:CodeBlock> => {
        let name_str = extract_identifier(name)?;
        let signature_str = extract_signature(s)?;
        FunctionDefNode::new_expr(name_str, vec![], signature_str, body?)
    },
    Function <name:Identifier> LParen <params:IdentifierList> => {
        Err("Falta ')' después de los parámetros".into())
    },
    Function <name:Identifier> LParen <params:IdentifierList> Colon <s:Signature> => {
        Err("Falta cuerpo de la función".into())
    },
    Function <name:Identifier> LParen RParen => {
        Err("Falta ':' después de la lista de parámetros".into())
    },
    Function <name:Identifier> LParen RParen Colon <s:Signature> => {
        Err("Falta cuerpo de la función".into())
    }
};

Expr: Result<Expression, String> = { 
    DestructiveAssignExpr,
    LogicalOrExpr
};

DestructiveAssignExpr: Result<Expression, String> = {
    <id:Identifier> DestructiveAssignOp <e:Expr> => {
        let id_str = extract_identifier(id)?;
        Ok(Expression::new_destructive_assign(id_str, e?))
    },
    
    <id:Identifier> DestructiveAssignOp => {
        Err("Falta expresión después de ':='".into())
    }
};

ExprsList: Result<ExpressionList, String> = {
    <v:(<Expr> Semicolon)*> <last:Expr?> => {
        // Convertimos el vector de Results en un Result de vector
        let mut vec: Vec<Expression> = v.into_iter().collect::<Result<Vec<_>, _>>()?;
        
        if let Some(e) = last {
            vec.push(e?);
        }
        
        Ok(ExpressionList::new(vec))
    }
};

LogicalOrExpr: Result<Expression, String> = {
    <l:LogicalOrExpr> <op:LogicalOrOp> <r:LogicalAndExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    LogicalAndExpr
};

LogicalAndExpr: Result<Expression, String> = {
    <l:LogicalAndExpr> <op:LogicalAndOp> <r:EqualityExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    EqualityExpr
};

EqualityExpr: Result<Expression, String> = {
    <l:EqualityExpr> <op:EqualityOp> <r:ComparisonExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    ComparisonExpr
};

ComparisonExpr: Result<Expression, String> = {
    <l:ComparisonExpr> <op:ComparisonOp> <r:TermExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    TermExpr
};

TermExpr: Result<Expression, String> = {
    <l:TermExpr> <op:TermOp> <r:FactorExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    FactorExpr
};

FactorExpr: Result<Expression, String> = {
    <l:FactorExpr> <op:FactorOp> <r:ExponentExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    ExponentExpr
};

ExponentExpr: Result<Expression, String> = {
    <l:UnaryExpr> <op:PowOp> <r:ExponentExpr> => {
        let op_token = extract_operator(op)?;
        l?.new_binary_op(op_token, r?)
    },
    UnaryExpr
};

UnaryExpr: Result<Expression, String> = {
    <op:UnaryOp> <e:UnaryExpr> => {
        let op_token = extract_operator(op)?;
        Ok(Expression::new_unary_op(op_token, e?))
    },
    PrimaryExpr
};

IdentifierList: Result<Vec<FunctionParams>, String> = {
    <first:Identifier> Colon <s:Signature> <rest:(Comma Identifier Colon Signature)*> => {
        let first_str = extract_identifier(first)?;
        let signature_str = extract_signature(s)?;
        let mut vec = vec![FunctionParams::new(first_str, signature_str)];
        
        for (_, id, _, sign) in rest {
            let id_str = extract_identifier(id)?;
            let sign_str = extract_signature(sign)?;
            vec.push(FunctionParams::new(id_str, sign_str));
        }
        Ok(vec)
    },
    <first:Identifier> Colon => Err("Falta firma después de ':'".into()),
    <first:Identifier> => Err("Falta ':' después del identificador".into())
};

Assignment: Result<Assignment, String> = {
    <id:Identifier> Assign <e:Expr> => {
        let id_str = extract_identifier(id)?;
        Ok(Assignment::new(id_str, e?))
    },
    <id:Identifier> Assign => {
        Err("Falta expresión después de '='".into())
    }
};

AssignmentList: Result<Vec<Assignment>, String> = {
    <first:Assignment> <rest:(<Comma> <Assignment>)*> => {
        let mut assignments = vec![first?];
        for (_, assignment) in rest {
            assignments.push(assignment?);
        }
        Ok(assignments)
    },
    // Manejar lista vacía si es necesario
    => Ok(Vec::new())
};

ArgList: Result<Vec<Expression>, String> = {
    <first:Expr> <rest:(<Comma> <Expr>)*> => {
        let mut args = vec![first?];
        for (_, expr) in rest {
            args.push(expr?);
        }
        Ok(args)
    },
    => Ok(Vec::new())
};

CodeBlock: Result<Expression, String> = {
    LBrace <body:ExprsList> RBrace => Ok(Expression::new_code_block(body?)),
    LBrace <body:ExprsList> => Err("Falta '}' al final del bloque de código".into())
};

LetIn: Result<Expression, String> = {
    Let <a:AssignmentList> In <body:PrimaryExpr> => {
        Ok(Expression::new_let_in(a?, body?))
    },
    Let <a:AssignmentList> => {
        Err("Falta 'in' en expresión let".into())
    }
};

WhileLoop: Result<Expression, String> = {
    While LParen <condition:Expr> RParen <body:PrimaryExpr> => {
        Ok(Expression::new_while_loop(condition?, body?))
    },
    While LParen <condition:Expr> => Err("Falta ')' o cuerpo en bucle while".into()),
    While => Err("Falta condición en bucle while".into())
};


ForLoop: Result<Expression, String> = {
    For LParen <id:Identifier> In <call:PrimaryExpr> RParen <body:PrimaryExpr> => {
        let id_str = extract_identifier(id)?;
        Ok(Expression::new_for_loop(id_str, call?, body?))
    },
    For LParen <id:Identifier> In => Err("Falta iterable en bucle for".into()),
    For LParen <id:Identifier> => Err("Falta 'in' en bucle for".into()),
    For LParen => Err("Falta identificador en bucle for".into()),
    For => Err("Falta '(' después de 'for'".into())
};

IfElse: Result<Expression, String> = {
    If LParen <condition:Expr> RParen <if_body:PrimaryExpr> Else <else_body:PrimaryExpr> => {
        Ok(Expression::new_if_else(condition?, if_body?, else_body?))
    },
    If LParen <condition:Expr> RParen <if_body:PrimaryExpr> => {
        Err("Falta 'else' en expresión if".into())
    },
    If LParen <condition:Expr> => Err("Falta ')' o cuerpo en expresión if".into())
};

PrimaryExpr: Result<Expression, String> = {
    CodeBlock?,    
    WhileLoop?,
    ForLoop?,
    <name:Identifier> LParen <args:ArgList> RParen => {
        let name_str = extract_identifier(name)?;
        Ok(Expression::new_function_call(name_str, args?))
    },
    <n:Num> => {
        let num_str = extract_number(n)?;
        Ok(Expression::new_number(num_str))
    },
    <s:Str> => {
        let str_val = extract_string(s)?;
        Ok(Expression::new_string(str_val))
    },
    <id:Identifier> => {
        let id_str = extract_identifier(id)?;
        Ok(Expression::new_identifier(id_str))
    },
    LParen <e:Expr> RParen => Ok(e?),
    LetIn?,
    True => Ok(Expression::new_boolean(true)),
    False => Ok(Expression::new_boolean(false)),
    IfElse?
};


Identifier: Token = {
    r"[A-Za-z][A-Za-z_0-9]*" => Token::Identifier(String::from_str(<>).unwrap()),
};

Num: Token = {
    r"[0-9]+(\.[0-9]+)?" => Token::Number(String::from_str(<>).unwrap()),
};

Str: Token = {
    r#""([^"\\]|\\.)*""# => Token::StringLiteral(String::from_str(&<>[1..<>.len()-1]).unwrap()),
};

// PrintExpr: Box<Expr> = {
//     Print LParen <Expr> RParen => Box::new(Expr::Print(<>)),
// };

UnaryOp: Token = {
    "!" => Token::Operator(OperatorToken::NOT),
    "-" => Token::Operator(OperatorToken::NEG),
};

PowOp: Token = {
    "^" => Token::Operator(OperatorToken::POW),
};

FactorOp: Token = {
    "*" => Token::Operator(OperatorToken::MUL),
    "/" => Token::Operator(OperatorToken::DIV),
    "%" => Token::Operator(OperatorToken::MOD),
};

TermOp: Token = {
    "+" => Token::Operator(OperatorToken::PLUS),
    "-" => Token::Operator(OperatorToken::MINUS),
    "@" => Token::Operator(OperatorToken::CONCAT),
};

ComparisonOp: Token = {
    ">" => Token::Operator(OperatorToken::GT),
    ">=" => Token::Operator(OperatorToken::GTE),
    "<" => Token::Operator(OperatorToken::LT),
    "<=" => Token::Operator(OperatorToken::LTE),
};

Function: Token = {
    "function" => Token::Keyword(KeywordToken::FUNCTION),
};


Arrow: Token = {
    "=>" => Token::Delimiter(DelimiterToken::ARROW),
};

EqualityOp: Token = {
    "==" => Token::Operator(OperatorToken::EQ),
    "!=" => Token::Operator(OperatorToken::NEQ),
};

Comma: Token = {
    "," => Token::Delimiter(DelimiterToken::COMMA),
};

Colon: Token = {
    ":" => Token::Delimiter(DelimiterToken::COLON),
};

Assign: Token = {
    "=" => Token::Operator(OperatorToken::ASSIGN),
};

DestructiveAssignOp: Token = {
    ":=" => Token::Operator(OperatorToken::DASSIGN),
};

LogicalAndOp: Token = {
    "&" => Token::Operator(OperatorToken::AND),
};

LogicalOrOp: Token = {
    "|" => Token::Operator(OperatorToken::OR),
};

Semicolon: Token = {
    ";" => Token::Delimiter(DelimiterToken::SEMICOLON),
};

LParen: Token = {
    "(" => Token::Delimiter(DelimiterToken::LPAREN),
};

RParen: Token = {
    ")" => Token::Delimiter(DelimiterToken::RPAREN),
};

RBrace: Token = {
    "}" => Token::Delimiter(DelimiterToken::RBRACE),
};

LBrace: Token = {
    "{" => Token::Delimiter(DelimiterToken::LBRACE),
};

Let: Token = {
    "let" =>Token::Keyword( KeywordToken::LET),
};

Else: Token = {
    "else" => Token::Keyword(KeywordToken::ELSE),
};

Elif: Token = {
    "elif" => Token::Keyword(KeywordToken::ELIF),
};

In: Token = {
    "in" => Token::Keyword(KeywordToken::IN),
};

If: Token = {
    "if" => Token::Keyword(KeywordToken::IF),
};

While: Token = {
    "while" => Token::Keyword(KeywordToken::WHILE),
};

For: Token = {
    "for" => Token::Keyword(KeywordToken::FOR),
};

// Print: KeywordToken = {
//     "print" => KeywordToken::PRINT,
// };

True: Token = {
    "true" => Token::Keyword(KeywordToken::TRUE),
};

False: Token = {
    "false" => Token::Keyword(KeywordToken::FALSE),
};

Signature: Token = {
    r"[A-Za-z][A-Za-z_0-9]*" => Token::Identifier(String::from_str(<>).unwrap()),
};

